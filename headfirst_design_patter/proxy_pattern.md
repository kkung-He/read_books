# 프록시(proxy) 패턴 이해하기 :star2:
 
 </br>
 </br>
 
 ```java
 ```
## 🎯 의도 
> 프록시 : 대리인 , 즉 무언가를 대신 처리하는 의미 -> 비서 </p>
> 사장님한테 물어보기 전에 비서에게 물어보세요! </p>
> 어떤 객체를 사용하고자 할때 객체를 직접적으로 참조하는 것이 아니라 해당 객체를 대행하는 객체를 통해 대상 객체에 접근하는 방식 </p>
> 이를 통해 해당 객체가 메모리에 존재하지 않아도 기본적 정보를 참조하거나 설정 할 수 있으며 </p>
> 또한 실제 객체의 기능이 반드시 필요한 시점까지 객체의 생성을 미룰 수 있다. </p>
 
 </br>
 </br>
 


## ✅ RMI

<img width="637" alt="RMI이해" src="https://user-images.githubusercontent.com/98209409/179329763-562baf63-b500-4bff-8e5a-1c3d64101794.png">

출처: https://bb-dochi.tistory.com/84
 
</br>
 
> 클라이언트 객체는 원격 객체의 메소드 호출한다고 생각하고 작업 처리한다 </p>
> 하지만 실제로는 로컬 힙에 들어있는 프록시 객체(클라이언트 보조 객체)의 메소드를 호출하고 있다. </p>
> 프록시는 메소드 호출정보(인자, 메소드 이름 등)를 잘 포장해서 네트워크로 서비스 보조 객체에게 전달한다.</p>
> 서버 쪽에선 서비스 보조 객체가 요청을 받고 해석해 실제 서비스 객체에 있는 메소드 호출, 리턴값(포장된 결과)을 전송한다. </p>

</br>

자바RMI
> 클라이언트 서비스 보조 객체 ( = RMI 스텁 ) + 서비스 보조 객체 ( = RMI 스켈레톤) 을 만들어줌 </p>
> 사용시 네트워킹 및 입출력 관련 코드를 직접 작성하지 않아도 됨 </p>
> 클라이언트에서 원격 객체에 접근할 수 있는 룩업 서비스 제공 </p>
> 클라이언트 입장에선 로컬 메소드 호출과 동일 방식으로 사용하면 되지만, 실제론 네트워킹 및 입출력 기능이 활용되고 있으므롤 예외처리 중요 </p>

</br>
</br>

## ✅ 원격 서비스 만들기 

</br>

### 1단계 : 원격 인터페이스 만들기
> 클라이언트에서 원격으로 호출할 수 있는 메소드 정의  </p>
> 클라이언트에서 이 인터페이스를 서비스 클래스 형식으로 사용 -> 스텁과 실제 서비스에 이 인터페이스 구현해야 함  </p>
</br>

>> 1. java.rmi.Remote를 반드시 확장하여 원격 인터페이스 정의. </p>
>> Remote는 표식용(marker) 인터페이스나 메소드가 없지만 RMI에서는 특별!  </p>
>> 2. 모든 메소드를 RemoteException을 던지도록 선언 - 네트워킹, 입출력 작업 중 생길 수 있는 예외 처리를 위함 </p>
>> 3. 원격 메소드의 인자와 리턴값은 반드시 원시 형식(primitive) 또는 Serializable 형식으로 선언 </p>
>> 메소드의 인자들은 네트워크를 통해 전달되어 직렬화를 통해 포장될 것 </p>
>> 즉 원시 형식이 아닌 직접 만든 형식을 사용한다면 클래스를 만들 때 Serialize 인터페이스 구현

</br>

### 2단계 : 서비스 구현 클래스 생성
> 실제 작업을 하는 클래스, 나중에 클라이언트에서 이 객체에 있는 메소드 호출 ex) GumballMachine </p>
> 1번의 인터페이스를 구현해야 함 </p>

</br>

### 3단계 : RMI 레지스트리 (rmiregistry) 실행하기
> 전화번호부와 비슷, 클라이언트는 이 레지스트리로부터 프록시(스텁, 클라이언트 보조 객체)를 받아 감
> rmiregistry 명령어 다른 터미널 창에서 실행

</br>

### 4단계 : 원격 서비스 실행
> 서비스를 구현한 클래스에서 서비스 인스터스를 만들고 그 인스턴스를 RMI 레지스트리에 등록 => 클라이어트에서 사용 가능해짐
> 스텁과 스켈레톤은 보이지 않는 곳에서 동적으로 생성된다.
> java MyServiceImp1

</br>
</br>

## ✅ 원격 프록시, 가상 프록시, 보호 프록시

</br>

### 원격 프록시 
> 원격 객체(다른 JVM에 들어있는 객체)에 대한 접근을 제어 할 수 있다. </p>
> 원격 프록시의 메소드를 호출하게 되면 네트워크를 통해 전달되어 원격 객체의 메소드가 호출되며 이러한 결과는 다시 클라이언트에게 전달됩니다.

</br>

<img width="700" alt="원격프록시" src="https://user-images.githubusercontent.com/98209409/179258892-473661e3-55a8-4916-afed-8262280e9a39.png">

출처 : https://plposer.tistory.com/31    </p>

</br>
</br>


### 가상 프록시 
> 생성하기 힘든 자원에 대해 접근을 제어 할 수 있다. </p>
> 실제 객체의 사용 시점을 제어 할 수 있다. 클라이언트가 처음 요청 및 접근 할 때만 실체 객체가 생성되며 </p>
> 이후는 프록시를 참조하여 실제 객체를 대신 할 수 있다. </p>

</br>

<img width="700" alt="가상프록시" src="https://user-images.githubusercontent.com/98209409/179261011-19c9002a-4849-41b2-acb6-9ce1a3969dec.png">

</br>
</br>

### 보호 프록시 
> 접근 권한이 필요한 자원에 대한 접근을 제어 할 수 있다.






