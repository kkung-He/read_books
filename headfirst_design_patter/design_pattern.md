# 디자인 패턴 이해하기 :star2:

</br>
</br>

## ✅ 패턴
> 특정 컨텍스트 내에서 주어진 문제의 해결책이다.

</br>
</br>

## ✅ 컨텍스트(context), 문제(problem), 해결책(solution)
- 컨텍스트 : 퍄턴이 적용되는 상황, 반복적으로 일어날 수 있는 상황이어야만 한다. </p>
  예) 객체들의 컬렉션이 주어져 있다.
- 문제 : 컨텍스트 내에서 이뤄야 하는 목표를 뜻한, 여기에는 컨텍스트 내의 제약조건도 포함된다 </p>
  예) 컬렉션의 구현을 드러내지 않으면서 그 안에 있는 각 객체를 대상으로 순환 작업을 할 수 있어야 한다.
- 해결책 : 바로 우리가 찾아내야 하는 것, 제약조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인을 뜻한다. </p>
  예) 반복 작업을 별도의 클래스로 캡슐화 한다.

</br>
</br>  

### 정의
>  ' 어떤 컨텍스트 내에서 일련의 제약 조건에 의해 영향을 받는 문제가 발생했다면,
>  그 제약조건 내에서 목적 달성을 위한 해결책이 되는 디자인을 적용하면 된다. ' 

</br>
</br>  

```java

```

## ✅ 패턴 카탈로그
-> p.605 그림 참조

</br>
</br>  


## ✅ 디자인 패턴 분류하기 1. 생성, 행동, 구조 패턴

</br>  

### 생성 패턴 (Creational Pattern) 은 객체 인스턴스를 생성하는 패턴으로 클라이언트와 그 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어 주는 패턴

</br>  

예) 싱글턴, 추상 팩토리, 팩토리 메소드 

### 행동 패턴 (Behavioral Pattern) 은 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴

</br>  

예) 템플릿메소드, 반복자, 옵저버, 상태, 전략 , 싱글턴

</br>  

### 구조 패턴 (Structural Pattern)은 클래스와 객체를 더 큰 구조로 만들 수 있게 구성을 사용하는 패턴 

</br> 

예) 데코레이터, 컴포지트, 프록시, 퍼사드, 어댑터

</br> 
</br>  

## ✅ 디자인 패턴 분류하기 2. 클래스, 객체 

</br> 

### 클래스 패턴은 클래스 사이의 관계가 상속으로 어떻게 정의되는지를 다룬다. 클래스 사이의 관계는 대부분 컴파일 할 때 결정 된다. 

</br> 

예) 템플릿 메소드, 팩토리 메소드, 어댑터 , 인터프리터 

</br> 

### 객체 패턴은 객체 사이의 관계를 다루며, 객체 사이의 관계는 보통 구성으로 정의된다. 일반적으로 실행중에 관계가 결정되므로 보다 동적이고 유연하다.

</br>

예) 컴포지트, 데코레이터, 퍼사드, 커맨드, 반복자, 전략, 프록시, 상태, 프로토타입, 추상팩토리, 싱글턴 등 

</br>

* 이 외에도 다른 분류 방법도 있다. 생성, 구조, 행동 으로 나누고 분리 패턴과 같은 식으로 하위 범주로 나누기도 한다. 하지만 3가지로 분류하는 것이 유명! </p>

* 꼭 하나의 범주에 속하는 건 아니다. </p>

* 데코레이터 패턴이 왜 구조 패턴에 있을까? 행동을 추가 하는 패턴이니 행동 패턴인거 같은데? </p>

  -> 데코레이터 패턴은 한 객체를 다른 객체로 감싸서 새로운 기능을 제공해 주는 패턴이다. </p>
     따라서 행동 패턴의 용도인 객체 사이의 통신과 상호연결보다는 객체를 동적으로 구성해서 새로운 기능을 얻는 쪽에 초점을 맞춰야 할 것이다.

</br>
</br>

## ✅ 패턴으로 생각하기 

> 1. 디자인을 할 때 무엇보다도 중요한 원칙은 최대한 단순한 방법(KISS, keep it Simple)으로 문제를 해결하기 이다. </p>
>  "어떻게 하면 단순하게 해결 할 수 있을까?" 에 초점 맞추기 </p>
  
</br>

> 2. 디자인 패턴은 만병 통치약이 아니다. 패턴은 반복적으로 발생하는 문제의 일반적이 해결책이다. </p>
> 그러므로 패턴 사용시에는 그 패턴이 우리가 설계한 디자인에 미칠 영향과 결과를 주의 깊게 생각해 봐야 한다.</p>

</br>

> 3. 패턴일 필요 할 때 . 디자인을 할 때 지금 디자인상의 문제에 적합하다는 확신이 든다면 패턴을 도입해야 한다. </p>
> 간단한 해결책으로 문제가 해결되는 데도 시스템의 어떤 부분이 변경 될거라고 예측 되는 상황에는 디자인 패턴을 적용해야 한다. </p>
> 패턴 도입을 디자인 단계에서만 고려해야 하는건 아니다. 나중에 리팩터링을 할때도 패턴 도입을 고려 할 수 있다. </p>

</br>

> 4. 리팩터링과 패턴 
> 리팩터링이란 코드를 변경해서 코드 구조를 개선하는 과정을 뜻한다. 리팩터링의 목적은 행동 변경이 아니라 구조 개선에 있다. </p>
> 패턴 사용의 아주 좋은 기회라 할 수 있다. </p>
> 꼭 필요하지 않은 패턴은 빼 버리자. 지금 있는 디자인에서 디자인 패턴을 제거하는 일을 두려워하지 말아라. -> 패턴보다 간단한 해결책이 더 나을것 같을 때는 패턴을 제거 하면 된다. </p>

</br>

> 5. 꼭 필요하지 않은 패턴을 미리 적용할 필요는 없다. </p>

</br>
</br>

## ✅ 패턴을 대하는 마음가짐 
- 초보자들은 언제나 패턴을 사용하려는 경향이 있다. 바람직한 일이다. </p>
- 그래서 패턴을 쓰면 더 좋은 디자인이 만들어 질 거라고 생각하지만 어느 순간 어떤 디자인이든 될 수 있으면 단순하게 만들어야 한다는 걸 터득한다.</p>
- 경험이 늘어 중급자 수준에 오르면 어떤 상황에 패턴일 필요하고 필요 하지 않은지 파악 할 수 있다.</p>
- 그랜드 마스터의 경지에 오르면 패턴을 자연스럽게 구사 할 수 있다. </p>

</br>
</br>

## ✅ 전문 용어의 위대함 - 용어를 공유하는 5가지 방법 
1. 디자인 회의에서 디자인 패턴을 사용하면 디자인 자체에 더 많은 시간을 할애 할 수 있다.  </p>
2. 다른 개발자들과 토론할 때 디자인 패턴을 사용해 보다.  </p>
3. 아키텍처 문서에 패턴을 활용하면 적은 분량으로 디자인을 분명하게 설명 할 수 있다.  </p>
4. 코드 주석을 달때 어떤 패턴을 사용하고 있는지 적고 클래스와 메소드 이름을 만들 때도 사용중이 패턴일 분명히 드러 날 수 있도록 해보자.  </p>
5. 개발자 모임에서 다른 사람들에게 알려주자. </p>

</br>
</br>

## ✅ 디자인 패턴 관련 자료 
-> p.623 에 웹사이트 추천이 있다. </p>

## ✅ 사악한 안티 패턴 섬멸하기 
> 안티 패턴은 어떤 문제의 나쁜 해결책에 이르는 길을 알려준다.</p>
> 안티 패턴은 어떤 이유로 나쁜 해결책에 유혹되는지 알려준다. </p>
> 안티 패턴은 장기적인 관점에서 그 해결책이 나쁜 이유를 알려준다. </p>
> 안티 패턴은 좋은 해결책을 만들 때 적용 할수 있는 다른 패턴을 제안해 준다. </p>

</br>

안티 패턴은 좋은 해결책 처럼 보이지만 적용하고 나서야 상당히 좋지 않은 해결책임이 밝혀진다. </p>
안티 패턴을 문서로 정리해 두면 다른 사람들이 나쁜 해결책을 구현하기 전에 그 문제점을 미리 파악하는데 도움을 줄 수있다. </p>
안티 패턴도 개발 안티 패턴, 객체지향 안티 패턴, 조직 안티 패턴 , 특정 영역 안티 패턴 같이 다양한 종류가 있다.</p>

</br>
</br>

## ✅ 객체지향 기초 
- 추상화, 캡슐화, 다형성, 상속 

</br>
</br>

## ✅ 객체지향 원칙
- 바뀌는 부분은 캡슐화 한다. </p>
- 상속보다는 구성을 활용한다.</p>
- 구현보다는 인터페이스에 맞춰서 프로그래밍 한다. </p>
- 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다. </p>
- 클래스는 확장에는 열려 있지만 변경에는 닫혀 있어야 한다. (OOP) </p>
- 추상화 된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다. </p>
- 진짜 절친에게만 얘기한다. </p>
- 먼저 연락하지 마세요 저희가 연락 드리겠습니다. </p>
- 어떤 클래스가 바뀌는 이유는 하나뿐이어야만 한다.    ...</p>

</br>
</br>
